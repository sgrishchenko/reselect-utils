(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{"QX/G":function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",(function(){return c})),t.d(n,"default",(function(){return i}));var r=t("Fcif"),o=t("+I+c"),a=(t("mXGw"),t("/FXl")),s=t("TjRS"),c=(t("aD51"),{});void 0!==c&&c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"docs/guides/chain-and-empty-selectors.md"}});var l={_frontmatter:c},p=s.a;function i(e){var n=e.components,t=Object(o.a)(e,["components"]);return Object(a.b)(p,Object(r.a)({},l,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"chain--empty-selectors"},"Chain & Empty Selectors"),Object(a.b)("h2",{id:"chain-selector"},"Chain Selector"),Object(a.b)("p",null,"If you design your state like a data base, you should be familiar with ",Object(a.b)("em",{parentName:"p"},"foreign keys"),". Imagine that you have this normalized state:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"const state = {\n  persons: {\n    1: {\n      id: 1,\n      firstName: 'Marry',\n      secondName: 'Poppins',\n    },\n    2: {\n      id: 2,\n      firstName: 'Harry',\n      secondName: 'Potter',\n    },\n  },\n\n  messages: {\n    100: {\n      id: 100,\n      personId: 1,\n      text: 'Hello',\n    },\n    200: {\n      id: 200,\n      personId: 2,\n      text: 'Buy',\n    },\n  },\n\n  documents: {\n    111: {\n      id: 111,\n      messageId: 100,\n    },\n    222: {\n      id: 222,\n      messageId: 200,\n    },\n  },\n};\n")),Object(a.b)("p",null,"And you need get a person by ",Object(a.b)("inlineCode",{parentName:"p"},"messageId"),". You can use next code to solve this problem:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-typescript"}),"const messagesSelector = (state: State) => state.messages;\nconst personsSelector = (state: State) => state.persons;\n\nconst messagePersonSelector = (state: State, props: { messageId: number }) => {\n  const message = messagesSelector(state)[props.messageId];\n\n  return messagesSelector(state)[message.personId];\n};\n")),Object(a.b)("p",null,"It is working solution, but you can't use this selector as input for ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/toomuchdesign/re-reselect#createcachedselector"}),"Cached Selector"),", because it fully uncached. Let's try to re-write this example via ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"https://github.com/toomuchdesign/re-reselect"}),"re-reselect"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-typescript"}),"import { createCachedSelector } from 're-reselect';\nimport { prop } from 'reselect-utils';\n\nconst messagePersonSelector = createCachedSelector(\n  [(state: State) => state, prop<{ messageId: number }>().messageId()],\n  (state, messageId) => {\n    const message = messagesSelector(state)[messageId];\n\n    return messagesSelector(state)[message.personId];\n  },\n)({\n  keySelector: prop<{ messageId: number }>().messageId(),\n});\n")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"Prop Selector")," is described ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"/reselect-utils/docz/guides/path-and-prop-selectors#prop-selector"}),"here"),". Now our solution has become only worth. This selector is still fully uncached, because it depends on whole state. Additionally, written selector has an ugly combiner, which calls other selectors right in body. Reselect Utils propose next way:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-typescript"}),"import { createCachedSelector } from 're-reselect';\nimport { prop, createChainSelector, createBoundSelector } from 'reselect-utils';\n\nconst personsSelector = (state: State) => state.persons;\nconst personSelector = createCachedSelector(\n  [personsSelector, prop<{ personId: number }>().personId()],\n  (persons, personId) => persons[personId],\n)({\n  keySelector: prop<{ personId: number }>().personId(),\n});\n\nconst messagesSelector = (state: State) => state.messages;\nconst messageSelector = createCachedSelector(\n  [messagesSelector, prop<{ messageId: number }>().messageId()],\n  (messages, messageId) => messages[messageId],\n)({\n  keySelector: prop<{ messageId: number }>().messageId(),\n});\n\nconst messagePersonSelector = createChainSelector(messageSelector)\n  .chain((message) =>\n    createBoundSelector(personSelector, { personId: message.id }),\n  )\n  .build();\n")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"Bound Selector")," is described ",Object(a.b)("a",Object(r.a)({parentName:"p"},{href:"/reselect-utils/docz/guides/bound-and-adapted-selectors#bound-selector"}),"here"),". You can build longer chains. For example, if you want find person by ",Object(a.b)("inlineCode",{parentName:"p"},"documentId")," you can add next code:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-typescript"}),"import { prop, chain, bound } from 'reselect-utils';\n\nconst documentsSelector = (state: State) => state.documents;\nconst documentSelector = createCachedSelector(\n  [documentsSelector, prop<{ documentId: number }>().documentId()],\n  (documents, documentId) => documents[documentId],\n)({\n  keySelector: prop<{ documentId: number }>().documentId(),\n});\n\nconst documentPersonSelector = chain(documentSelector)\n  .chain((document) => bound(messageSelector, { messageId: document.id }))\n  .chain((message) => bound(personSelector, { personId: message.id }))\n  .build();\n")),Object(a.b)("p",null,"Here we have used compact aliases ",Object(a.b)("inlineCode",{parentName:"p"},"chain")," and ",Object(a.b)("inlineCode",{parentName:"p"},"bound")," to reduce code. Now if we call ",Object(a.b)("inlineCode",{parentName:"p"},"documentPersonSelector")," with state declared above, we can receive next results:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-typescript"}),"documentPersonSelector(state, { documentId: 111 }); // => { firstName: 'Marry', ... }\n\ndocumentPersonSelector(state, { documentId: 222 }); // => { firstName: 'Harry', ... }\n")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"Chain Selector")," uses monad pattern like the Promises. In chain callback you receive result of previous selector, and you should return a new derived selector. ",Object(a.b)("inlineCode",{parentName:"p"},"Chain Selector")," is flexible enough, you can make decisions and use conditions in chain callback:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-typescript"}),"import { createCachedSelector } from 're-reselect';\nimport { prop, chain } from 'reselect-utils';\n\nconst personsSelector = (state: State) => state.persons;\n\nconst personSelector = createCachedSelector(\n  [personsSelector, prop<{ personId: number }>().personId()],\n  (persons, personId) => persons[personId],\n)({\n  keySelector: prop<{ personId: number }>().personId(),\n});\n\nconst fullNameSelector = createCachedSelector(\n  [personSelector],\n  ({ firstName, secondName }) => `${firstName} ${secondName}`,\n)({\n  keySelector: prop<{ personId: number }>().personId(),\n});\n\nconst shortNameSelector = createCachedSelector(\n  [personSelector],\n  ({ firstName, secondName }) => `${firstName[0]}. ${secondName}`,\n);\n\nconst nameSelector = chain(prop<{ isShort: boolean }>().isShort())\n  .chain((isShort) => (isShort ? shortNameSelector : fullNameSelector))\n  .build();\n\nnameSelector(state, { personId: 1, isShort: false }); // => 'Marry Poppins'\nnameSelector(state, { personId: 1, isShort: true }); // => 'M. Poppins'\n")),Object(a.b)("p",null,"Here we change business logic implementation dynamically by ",Object(a.b)("inlineCode",{parentName:"p"},"isShort")," property."),Object(a.b)("h2",{id:"empty-selector"},"Empty Selector"),Object(a.b)("p",null,"Another place where we can use conditional chaining is ",Object(a.b)("em",{parentName:"p"},"optional foreign keys"),". For example, we have next structure:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-typescript"}),"type Parent = {\n  parentId: number;\n};\n\ntype Child = {\n  childId: number;\n  parentId?: number;\n};\n\ntype State = {\n  firstGeneration: Record<number, Parent>;\n  secondGeneration: Record<number, Child>;\n};\n\nconst exampleState: State = {\n  firstGeneration: {\n    1: { parentId: 1 },\n    2: { parentId: 2 },\n  },\n  secondGeneration: {\n    101: { childId: 101, parentId: 1 },\n    102: { childId: 102 },\n  },\n};\n")),Object(a.b)("p",null,"As you can see, child with id ",Object(a.b)("inlineCode",{parentName:"p"},"102")," haven't a parent, so this relation is optional. We can write next selector for this case:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-typescript"}),"import { createCachedSelector } from 're-reselect';\nimport { prop, chain, bound, empty } from 'reselect-utils';\n\nconst parentsSelector = (state: State) => state.firstGeneration;\nconst parentSelector = createCachedSelector(\n  [parentsSelector, prop<{ parentId: number }>().parentId()],\n  (parents, personId) => persons[personId],\n)({\n  keySelector: prop<{ parentId: number }>().parentId(),\n});\n\nconst childrenSelector = (state: State) => state.secondGeneration;\nconst childSelector = createCachedSelector(\n  [childrenSelector, prop<{ childId: number }>().childId()],\n  (children, childId) => children[childId],\n)({\n  keySelector: prop<{ childId: number }>().childId(),\n});\n\nconst parentByChildSelector = chain(childSelector)\n  .chain(({ parentId }) => {\n    return parentId !== undefined\n      ? bound(parentSelector, {\n          parentId,\n        })\n      : empty(parentSelector); // <- Pay attention here\n  })\n  .build();\n")),Object(a.b)("p",null,"We have used ",Object(a.b)("inlineCode",{parentName:"p"},"Empty Selector")," here. ",Object(a.b)("inlineCode",{parentName:"p"},"Empty Selector")," is a selector, which always returns ",Object(a.b)("inlineCode",{parentName:"p"},"undefined"),". You can just write ",Object(a.b)("inlineCode",{parentName:"p"},"() => undefined")," instead, but ",Object(a.b)("inlineCode",{parentName:"p"},"empty")," will help you to infer types correctly. Also you can use more verbose helper alias: ",Object(a.b)("inlineCode",{parentName:"p"},"createEmptySelector"),"."),Object(a.b)("h2",{id:"aggregation"},"Aggregation"),Object(a.b)("p",null,"Another task, that can be solved via ",Object(a.b)("inlineCode",{parentName:"p"},"Chain Selector"),", is aggregation. For example, you have these selectors:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-typescript"}),"import { createCachedSelector } from 're-reselect';\nimport { prop } from 'reselect-utils';\n\nconst personsSelector = (state: State) => state.persons;\n\nconst personSelector = createCachedSelector(\n  [personsSelector, prop<{ personId: number }>().personId()],\n  (persons, personId) => persons[personId],\n)({\n  keySelector: prop<{ personId: number }>().personId(),\n});\n\nconst fullNameSelector = createCachedSelector(\n  [personSelector],\n  ({ firstName, secondName }) => `${firstName} ${secondName}`,\n)({\n  keySelector: prop<{ personId: number }>().personId(),\n});\n")),Object(a.b)("p",null,"And you need find out the longest full name. You can use ",Object(a.b)("inlineCode",{parentName:"p"},"Chain Selector")," next way:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-typescript"}),"import { chain, bound, seq } from 'reselect-utils';\n\nconst longestFullNameSelector = chain(personsSelector) // (1)\n  .chain((persons) =>\n    seq(\n      // (2)\n      Object.values(persons).map(\n        (person) => bound(fullNameSelector, { personId: person.id }), // (3)\n      ),\n    ),\n  )\n  .map((\n    fullNames, // (4)\n  ) =>\n    fullNames.reduce((longest, current) =>\n      current.length > longest.length ? current : longest,\n    ),\n  )\n  .build();\n")),Object(a.b)("p",null,"What happens here? At first, we select persons normalized structure in point ",Object(a.b)("inlineCode",{parentName:"p"},"(1)"),". Next we use ",Object(a.b)("inlineCode",{parentName:"p"},"Sequence Selector")," to create the aggregated selector from selector array in point ",Object(a.b)("inlineCode",{parentName:"p"},"(2)"),". Each selector in selector array is ",Object(a.b)("inlineCode",{parentName:"p"},"Bound Selector"),", see point ",Object(a.b)("inlineCode",{parentName:"p"},"(3)"),". Finally, we use ",Object(a.b)("inlineCode",{parentName:"p"},"map")," method in point ",Object(a.b)("inlineCode",{parentName:"p"},"(4)")," to transform array of full names to the longest full method. The ",Object(a.b)("inlineCode",{parentName:"p"},"map")," method is like the ",Object(a.b)("inlineCode",{parentName:"p"},"chain")," method, but you can return calculated value from it instead of derived selector."),Object(a.b)("p",null,"Both of ",Object(a.b)("inlineCode",{parentName:"p"},"map")," and ",Object(a.b)("inlineCode",{parentName:"p"},"chain")," methods are cached. It means, that passed to them callback will not be called while result from a previous selector in a chain is the same."),Object(a.b)("h2",{id:"unit-tests"},"Unit Tests"),Object(a.b)("p",null,"You can test logic in your ",Object(a.b)("inlineCode",{parentName:"p"},"Chain Selectors"),". Created ",Object(a.b)("inlineCode",{parentName:"p"},"Chain Selector")," exposes special static field ",Object(a.b)("inlineCode",{parentName:"p"},"chainHierarchy"),". You can use this field in your unit tests next way:"),Object(a.b)("pre",null,Object(a.b)("code",Object(r.a)({parentName:"pre"},{className:"language-typescript"}),"const documentPersonSelector = chain(documentSelector)\n  .chain((document) => bound(messageSelector, { messageId: document.id }))\n  .chain((message) => bound(personSelector, { personId: message.id }))\n  .build();\n\nconst samplePerson = { id: 1 };\nconst sampleMessage = { id: 100 };\nconst sampleDocument = { id: 111 };\n\nconst state = {\n  persons: {\n    1: samplePerson,\n  },\n\n  messages: {\n    100: sampleMessage,\n  },\n\n  documents: {\n    111: sampleDocument,\n  },\n};\n\nconst boundPersonSelector = documentPersonSelector.chainHierarchy(\n  sampleMessage,\n);\nexpect(boundPersonSelector(state)).toBe(samplePerson);\n\nconst boundMessageSelector = documentPersonSelector.chainHierarchy.parentChain(\n  sampleDocument,\n);\nexpect(boundMessageSelector(state)).toBe(sampleMessage);\n")))}void 0!==i&&i&&i===Object(i)&&Object.isExtensible(i)&&!i.hasOwnProperty("__filemeta")&&Object.defineProperty(i,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"docs/guides/chain-and-empty-selectors.md"}}),i.isMDXComponent=!0}}]);
//# sourceMappingURL=component---docs-guides-chain-and-empty-selectors-md-3d974d705d7ae863fc5f.js.map