{"version":3,"sources":["webpack:///../docs/guides/chain-and-empty-selectors.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---docs-guides-chain-and-empty-selectors-md-3d974d705d7ae863fc5f.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/travis/build/sgrishchenko/reselect-utils/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"chain--empty-selectors\"\n    }}>{`Chain & Empty Selectors`}</h1>\n    <h2 {...{\n      \"id\": \"chain-selector\"\n    }}>{`Chain Selector`}</h2>\n    <p>{`If you design your state like a data base, you should be familiar with `}<em parentName=\"p\">{`foreign keys`}</em>{`. Imagine that you have this normalized state:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-js\"\n      }}>{`const state = {\n  persons: {\n    1: {\n      id: 1,\n      firstName: 'Marry',\n      secondName: 'Poppins',\n    },\n    2: {\n      id: 2,\n      firstName: 'Harry',\n      secondName: 'Potter',\n    },\n  },\n\n  messages: {\n    100: {\n      id: 100,\n      personId: 1,\n      text: 'Hello',\n    },\n    200: {\n      id: 200,\n      personId: 2,\n      text: 'Buy',\n    },\n  },\n\n  documents: {\n    111: {\n      id: 111,\n      messageId: 100,\n    },\n    222: {\n      id: 222,\n      messageId: 200,\n    },\n  },\n};\n`}</code></pre>\n    <p>{`And you need get a person by `}<inlineCode parentName=\"p\">{`messageId`}</inlineCode>{`. You can use next code to solve this problem:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const messagesSelector = (state: State) => state.messages;\nconst personsSelector = (state: State) => state.persons;\n\nconst messagePersonSelector = (state: State, props: { messageId: number }) => {\n  const message = messagesSelector(state)[props.messageId];\n\n  return messagesSelector(state)[message.personId];\n};\n`}</code></pre>\n    <p>{`It is working solution, but you can't use this selector as input for `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/toomuchdesign/re-reselect#createcachedselector\"\n      }}>{`Cached Selector`}</a>{`, because it fully uncached. Let's try to re-write this example via `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/toomuchdesign/re-reselect\"\n      }}>{`re-reselect`}</a>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { createCachedSelector } from 're-reselect';\nimport { prop } from 'reselect-utils';\n\nconst messagePersonSelector = createCachedSelector(\n  [(state: State) => state, prop<{ messageId: number }>().messageId()],\n  (state, messageId) => {\n    const message = messagesSelector(state)[messageId];\n\n    return messagesSelector(state)[message.personId];\n  },\n)({\n  keySelector: prop<{ messageId: number }>().messageId(),\n});\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`Prop Selector`}</inlineCode>{` is described `}<a parentName=\"p\" {...{\n        \"href\": \"/reselect-utils/docz/guides/path-and-prop-selectors#prop-selector\"\n      }}>{`here`}</a>{`. Now our solution has become only worth. This selector is still fully uncached, because it depends on whole state. Additionally, written selector has an ugly combiner, which calls other selectors right in body. Reselect Utils propose next way:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { createCachedSelector } from 're-reselect';\nimport { prop, createChainSelector, createBoundSelector } from 'reselect-utils';\n\nconst personsSelector = (state: State) => state.persons;\nconst personSelector = createCachedSelector(\n  [personsSelector, prop<{ personId: number }>().personId()],\n  (persons, personId) => persons[personId],\n)({\n  keySelector: prop<{ personId: number }>().personId(),\n});\n\nconst messagesSelector = (state: State) => state.messages;\nconst messageSelector = createCachedSelector(\n  [messagesSelector, prop<{ messageId: number }>().messageId()],\n  (messages, messageId) => messages[messageId],\n)({\n  keySelector: prop<{ messageId: number }>().messageId(),\n});\n\nconst messagePersonSelector = createChainSelector(messageSelector)\n  .chain((message) =>\n    createBoundSelector(personSelector, { personId: message.id }),\n  )\n  .build();\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`Bound Selector`}</inlineCode>{` is described `}<a parentName=\"p\" {...{\n        \"href\": \"/reselect-utils/docz/guides/bound-and-adapted-selectors#bound-selector\"\n      }}>{`here`}</a>{`. You can build longer chains. For example, if you want find person by `}<inlineCode parentName=\"p\">{`documentId`}</inlineCode>{` you can add next code:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { prop, chain, bound } from 'reselect-utils';\n\nconst documentsSelector = (state: State) => state.documents;\nconst documentSelector = createCachedSelector(\n  [documentsSelector, prop<{ documentId: number }>().documentId()],\n  (documents, documentId) => documents[documentId],\n)({\n  keySelector: prop<{ documentId: number }>().documentId(),\n});\n\nconst documentPersonSelector = chain(documentSelector)\n  .chain((document) => bound(messageSelector, { messageId: document.id }))\n  .chain((message) => bound(personSelector, { personId: message.id }))\n  .build();\n`}</code></pre>\n    <p>{`Here we have used compact aliases `}<inlineCode parentName=\"p\">{`chain`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`bound`}</inlineCode>{` to reduce code. Now if we call `}<inlineCode parentName=\"p\">{`documentPersonSelector`}</inlineCode>{` with state declared above, we can receive next results:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`documentPersonSelector(state, { documentId: 111 }); // => { firstName: 'Marry', ... }\n\ndocumentPersonSelector(state, { documentId: 222 }); // => { firstName: 'Harry', ... }\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`Chain Selector`}</inlineCode>{` uses monad pattern like the Promises. In chain callback you receive result of previous selector, and you should return a new derived selector. `}<inlineCode parentName=\"p\">{`Chain Selector`}</inlineCode>{` is flexible enough, you can make decisions and use conditions in chain callback:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { createCachedSelector } from 're-reselect';\nimport { prop, chain } from 'reselect-utils';\n\nconst personsSelector = (state: State) => state.persons;\n\nconst personSelector = createCachedSelector(\n  [personsSelector, prop<{ personId: number }>().personId()],\n  (persons, personId) => persons[personId],\n)({\n  keySelector: prop<{ personId: number }>().personId(),\n});\n\nconst fullNameSelector = createCachedSelector(\n  [personSelector],\n  ({ firstName, secondName }) => \\`\\${firstName} \\${secondName}\\`,\n)({\n  keySelector: prop<{ personId: number }>().personId(),\n});\n\nconst shortNameSelector = createCachedSelector(\n  [personSelector],\n  ({ firstName, secondName }) => \\`\\${firstName[0]}. \\${secondName}\\`,\n);\n\nconst nameSelector = chain(prop<{ isShort: boolean }>().isShort())\n  .chain((isShort) => (isShort ? shortNameSelector : fullNameSelector))\n  .build();\n\nnameSelector(state, { personId: 1, isShort: false }); // => 'Marry Poppins'\nnameSelector(state, { personId: 1, isShort: true }); // => 'M. Poppins'\n`}</code></pre>\n    <p>{`Here we change business logic implementation dynamically by `}<inlineCode parentName=\"p\">{`isShort`}</inlineCode>{` property.`}</p>\n    <h2 {...{\n      \"id\": \"empty-selector\"\n    }}>{`Empty Selector`}</h2>\n    <p>{`Another place where we can use conditional chaining is `}<em parentName=\"p\">{`optional foreign keys`}</em>{`. For example, we have next structure:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`type Parent = {\n  parentId: number;\n};\n\ntype Child = {\n  childId: number;\n  parentId?: number;\n};\n\ntype State = {\n  firstGeneration: Record<number, Parent>;\n  secondGeneration: Record<number, Child>;\n};\n\nconst exampleState: State = {\n  firstGeneration: {\n    1: { parentId: 1 },\n    2: { parentId: 2 },\n  },\n  secondGeneration: {\n    101: { childId: 101, parentId: 1 },\n    102: { childId: 102 },\n  },\n};\n`}</code></pre>\n    <p>{`As you can see, child with id `}<inlineCode parentName=\"p\">{`102`}</inlineCode>{` haven't a parent, so this relation is optional. We can write next selector for this case:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { createCachedSelector } from 're-reselect';\nimport { prop, chain, bound, empty } from 'reselect-utils';\n\nconst parentsSelector = (state: State) => state.firstGeneration;\nconst parentSelector = createCachedSelector(\n  [parentsSelector, prop<{ parentId: number }>().parentId()],\n  (parents, personId) => persons[personId],\n)({\n  keySelector: prop<{ parentId: number }>().parentId(),\n});\n\nconst childrenSelector = (state: State) => state.secondGeneration;\nconst childSelector = createCachedSelector(\n  [childrenSelector, prop<{ childId: number }>().childId()],\n  (children, childId) => children[childId],\n)({\n  keySelector: prop<{ childId: number }>().childId(),\n});\n\nconst parentByChildSelector = chain(childSelector)\n  .chain(({ parentId }) => {\n    return parentId !== undefined\n      ? bound(parentSelector, {\n          parentId,\n        })\n      : empty(parentSelector); // <- Pay attention here\n  })\n  .build();\n`}</code></pre>\n    <p>{`We have used `}<inlineCode parentName=\"p\">{`Empty Selector`}</inlineCode>{` here. `}<inlineCode parentName=\"p\">{`Empty Selector`}</inlineCode>{` is a selector, which always returns `}<inlineCode parentName=\"p\">{`undefined`}</inlineCode>{`. You can just write `}<inlineCode parentName=\"p\">{`() => undefined`}</inlineCode>{` instead, but `}<inlineCode parentName=\"p\">{`empty`}</inlineCode>{` will help you to infer types correctly. Also you can use more verbose helper alias: `}<inlineCode parentName=\"p\">{`createEmptySelector`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"aggregation\"\n    }}>{`Aggregation`}</h2>\n    <p>{`Another task, that can be solved via `}<inlineCode parentName=\"p\">{`Chain Selector`}</inlineCode>{`, is aggregation. For example, you have these selectors:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { createCachedSelector } from 're-reselect';\nimport { prop } from 'reselect-utils';\n\nconst personsSelector = (state: State) => state.persons;\n\nconst personSelector = createCachedSelector(\n  [personsSelector, prop<{ personId: number }>().personId()],\n  (persons, personId) => persons[personId],\n)({\n  keySelector: prop<{ personId: number }>().personId(),\n});\n\nconst fullNameSelector = createCachedSelector(\n  [personSelector],\n  ({ firstName, secondName }) => \\`\\${firstName} \\${secondName}\\`,\n)({\n  keySelector: prop<{ personId: number }>().personId(),\n});\n`}</code></pre>\n    <p>{`And you need find out the longest full name. You can use `}<inlineCode parentName=\"p\">{`Chain Selector`}</inlineCode>{` next way:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { chain, bound, seq } from 'reselect-utils';\n\nconst longestFullNameSelector = chain(personsSelector) // (1)\n  .chain((persons) =>\n    seq(\n      // (2)\n      Object.values(persons).map(\n        (person) => bound(fullNameSelector, { personId: person.id }), // (3)\n      ),\n    ),\n  )\n  .map((\n    fullNames, // (4)\n  ) =>\n    fullNames.reduce((longest, current) =>\n      current.length > longest.length ? current : longest,\n    ),\n  )\n  .build();\n`}</code></pre>\n    <p>{`What happens here? At first, we select persons normalized structure in point `}<inlineCode parentName=\"p\">{`(1)`}</inlineCode>{`. Next we use `}<inlineCode parentName=\"p\">{`Sequence Selector`}</inlineCode>{` to create the aggregated selector from selector array in point `}<inlineCode parentName=\"p\">{`(2)`}</inlineCode>{`. Each selector in selector array is `}<inlineCode parentName=\"p\">{`Bound Selector`}</inlineCode>{`, see point `}<inlineCode parentName=\"p\">{`(3)`}</inlineCode>{`. Finally, we use `}<inlineCode parentName=\"p\">{`map`}</inlineCode>{` method in point `}<inlineCode parentName=\"p\">{`(4)`}</inlineCode>{` to transform array of full names to the longest full method. The `}<inlineCode parentName=\"p\">{`map`}</inlineCode>{` method is like the `}<inlineCode parentName=\"p\">{`chain`}</inlineCode>{` method, but you can return calculated value from it instead of derived selector.`}</p>\n    <p>{`Both of `}<inlineCode parentName=\"p\">{`map`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`chain`}</inlineCode>{` methods are cached. It means, that passed to them callback will not be called while result from a previous selector in a chain is the same.`}</p>\n    <h2 {...{\n      \"id\": \"unit-tests\"\n    }}>{`Unit Tests`}</h2>\n    <p>{`You can test logic in your `}<inlineCode parentName=\"p\">{`Chain Selectors`}</inlineCode>{`. Created `}<inlineCode parentName=\"p\">{`Chain Selector`}</inlineCode>{` exposes special static field `}<inlineCode parentName=\"p\">{`chainHierarchy`}</inlineCode>{`. You can use this field in your unit tests next way:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const documentPersonSelector = chain(documentSelector)\n  .chain((document) => bound(messageSelector, { messageId: document.id }))\n  .chain((message) => bound(personSelector, { personId: message.id }))\n  .build();\n\nconst samplePerson = { id: 1 };\nconst sampleMessage = { id: 100 };\nconst sampleDocument = { id: 111 };\n\nconst state = {\n  persons: {\n    1: samplePerson,\n  },\n\n  messages: {\n    100: sampleMessage,\n  },\n\n  documents: {\n    111: sampleDocument,\n  },\n};\n\nconst boundPersonSelector = documentPersonSelector.chainHierarchy(\n  sampleMessage,\n);\nexpect(boundPersonSelector(state)).toBe(samplePerson);\n\nconst boundMessageSelector = documentPersonSelector.chainHierarchy.parentChain(\n  sampleDocument,\n);\nexpect(boundMessageSelector(state)).toBe(sampleMessage);\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}