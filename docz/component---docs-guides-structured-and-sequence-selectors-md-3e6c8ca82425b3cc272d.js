(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{Had6:function(e,t,r){"use strict";r.r(t),r.d(t,"_frontmatter",(function(){return a})),r.d(t,"default",(function(){return i}));var s=r("Fcif"),n=r("+I+c"),o=(r("mXGw"),r("/FXl")),c=r("TjRS"),a=(r("aD51"),{});void 0!==a&&a&&a===Object(a)&&Object.isExtensible(a)&&!a.hasOwnProperty("__filemeta")&&Object.defineProperty(a,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"docs/guides/structured-and-sequence-selectors.md"}});var p={_frontmatter:a},l=c.a;function i(e){var t=e.components,r=Object(n.a)(e,["components"]);return Object(o.b)(l,Object(s.a)({},p,r,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h1",{id:"structured--sequence-selectors"},"Structured & Sequence Selectors"),Object(o.b)("h2",{id:"structured-selector"},"Structured Selector"),Object(o.b)("p",null,"If you ever used ",Object(o.b)("a",Object(s.a)({parentName:"p"},{href:"https://github.com/reduxjs/reselect"}),"Reselect"),", you must be familiar with ",Object(o.b)("a",Object(s.a)({parentName:"p"},{href:"https://github.com/reduxjs/reselect#createstructuredselectorinputselectors-selectorcreator--createselector"}),"Structured Selector"),". Reselect Utils provides implementation of this helper but with improved typings. You can use ",Object(o.b)("inlineCode",{parentName:"p"},"Structured Selector")," from this library with heterogeneous selectors. Heterogeneous selectors are selectors with different types of state. See example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(s.a)({parentName:"pre"},{className:"language-typescript"}),"type PersonsStateSlice = {\n  persons: Record<number, Person>;\n};\n\nconst personsSelector = (state: PersonsStateSlice) => state.persons;\n\ntype MessagesStateSlice = {\n  messages: Record<number, Message>;\n};\n\nconst messagesSelector = (state: MessagesStateSlice) => state.messages;\n")),Object(o.b)("p",null,"Now we can write a selector what select data from both state slices:"),Object(o.b)("pre",null,Object(o.b)("code",Object(s.a)({parentName:"pre"},{className:"language-typescript"}),"import { createStructuredSelector } from 'reselect-utils';\n\nconst personsAndMessagesSelector = createStructuredSelector({\n  persons: personsSelector,\n  messages: messagesSelector,\n});\n")),Object(o.b)("p",null,"You can also use alias to reduce code:"),Object(o.b)("pre",null,Object(o.b)("code",Object(s.a)({parentName:"pre"},{className:"language-typescript"}),"import { struct } from 'reselect-utils';\n\nconst personsAndMessagesSelector = struct({\n  persons: personsSelector,\n  messages: messagesSelector,\n});\n")),Object(o.b)("h2",{id:"cached-structured-selector"},"Cached Structured Selector"),Object(o.b)("p",null,"If you use a parametric selector, you can use ",Object(o.b)("a",Object(s.a)({parentName:"p"},{href:"https://github.com/toomuchdesign/re-reselect"}),"Re-reselect"),". Reselect Utils provides ",Object(o.b)("inlineCode",{parentName:"p"},"Cached Structured Selector")," for these purposes. For example, we have next selectors:"),Object(o.b)("pre",null,Object(o.b)("code",Object(s.a)({parentName:"pre"},{className:"language-typescript"}),"import { createCachedSelector } from 're-reselect';\n\nconst personSelector = createCachedSelector(\n  personsSelector,\n  (state: PersonsStateSlice, props: Props) => props.personId,\n  (persons, personId) => persons[personId],\n)({\n  keySelector: (state, props) => props.personId,\n});\n\nconst messageSelector = createCachedSelector(\n  messagesSelector,\n  (state: MessagesStateSlice, props: Props) => props.messageId,\n  (messages, messageId) => messages[messageId],\n)({\n  keySelector: (state, props) => props.messageId,\n});\n")),Object(o.b)("p",null,"You can write composing selector this way:"),Object(o.b)("pre",null,Object(o.b)("code",Object(s.a)({parentName:"pre"},{className:"language-typescript"}),"import { cachedStruct } from 'reselect-utils';\n\nconst personAndMessageSelector = cachedStruct({\n  persons: personSelector,\n  messages: messageSelector,\n})({ keySelector: (state, props) => `${props.personId}:${props.messageId}` });\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"cachedStruct")," is short alias for ",Object(o.b)("inlineCode",{parentName:"p"},"Cached Structured Selector"),"."),Object(o.b)("h2",{id:"sequence-selector"},"Sequence Selector"),Object(o.b)("p",null,"There is also another type of structure besides objects - arrays. Reselect Utils provides ",Object(o.b)("inlineCode",{parentName:"p"},"Sequence Selector")," helper for them:"),Object(o.b)("pre",null,Object(o.b)("code",Object(s.a)({parentName:"pre"},{className:"language-typescript"}),"import { createCachedSelector } from 're-reselect';\nimport { bound, createSequenceSelector } from 'reselect-utils';\n\nconst personSelector = createCachedSelector(\n  personsSelector,\n  (state: PersonsStateSlice, props: Props) => props.personId,\n  (persons, personId) => persons[personId],\n)({\n  keySelector: (state, props) => props.personId,\n});\n\nconst firstPersonSelector = bound(personSelector, { personId: 1 });\nconst secondPersonSelector = bound(personSelector, { personId: 2 });\n\nconst firstTwoPersonsSelector = createSequenceSelector([\n  firstPersonSelector,\n  secondPersonSelector,\n]);\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Bound Selector")," is described ",Object(o.b)("a",Object(s.a)({parentName:"p"},{href:"/reselect-utils/docz/guides/bound-and-adapted-selectors#bound-selector"}),"here"),". Now if you have next state, you will receive next result:"),Object(o.b)("pre",null,Object(o.b)("code",Object(s.a)({parentName:"pre"},{className:"language-typescript"}),"const state = {\n  persons: {\n    1: {\n      id: 1,\n      firstName: 'Marry',\n      secondName: 'Poppins',\n    },\n    2: {\n      id: 2,\n      firstName: 'Harry',\n      secondName: 'Potter',\n    },\n  },\n};\n\nfirstTwoPersonsSelector(state); // => [{ firstName: 'Marry', ... }, { firstName: 'Harry', ... }]\n")),Object(o.b)("h2",{id:"cached-sequence-selector"},"Cached Sequence Selector"),Object(o.b)("p",null,"If you try to combine parametric selectors, there is a cached version of ",Object(o.b)("inlineCode",{parentName:"p"},"Sequence Selector"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(s.a)({parentName:"pre"},{className:"language-typescript"}),"import { createCachedSelector } from 're-reselect';\nimport { path, prop, bound, cachedSeq } from 'reselect-utils';\n\ntype Props = {\n  personId: number;\n  postfix: string;\n};\n\nconst personFullNameSelector = createCachedSelector(\n  path(personSelector).firstName(),\n  path(personSelector).secondName(),\n  prop<Props>().postfix(),\n  (firstName, secondName, postfix) => `${firstName} ${secondName} (${postfix})`,\n)({\n  keySelector: (state, props) => `${props.personId}:${props.postfix}`,\n});\n\nconst firstPersonFullNameSelector = bound(personFullNameSelector, {\n  personId: 1,\n});\nconst secondPersonFullNameSelector = bound(personFullNameSelector, {\n  personId: 2,\n});\n\nconst firstTwoPersonFullNamesSelector = cachedSeq([\n  firstPersonFullNameSelector,\n  secondPersonFullNameSelector,\n])({\n  keySelector: prop<Props>().postfix(),\n});\n\nfirstTwoPersonsSelector(state, { postfix: '*' }); // => ['Marry Poppins (*)', 'Harry Potter (*)' }]\n\nfirstTwoPersonsSelector(state, { postfix: '?' }); // => ['Marry Poppins (?)', 'Harry Potter (?)' }]\n")),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"Path Selector")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Prop Selector")," are described ",Object(o.b)("a",Object(s.a)({parentName:"p"},{href:"/reselect-utils/docz/guides/path-and-prop-selectors"}),"here"),"."))}void 0!==i&&i&&i===Object(i)&&Object.isExtensible(i)&&!i.hasOwnProperty("__filemeta")&&Object.defineProperty(i,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"docs/guides/structured-and-sequence-selectors.md"}}),i.isMDXComponent=!0}}]);
//# sourceMappingURL=component---docs-guides-structured-and-sequence-selectors-md-3e6c8ca82425b3cc272d.js.map