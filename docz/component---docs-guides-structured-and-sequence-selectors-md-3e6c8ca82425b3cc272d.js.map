{"version":3,"sources":["webpack:///../docs/guides/structured-and-sequence-selectors.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"wPAQaA,G,UAAe,S,kOAC5B,IAAMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,EACF,8BACD,OAAO,YAACJ,EAAD,eAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,kCADR,mCAGA,iBAAQ,CACN,GAAM,uBADR,uBAGA,yCAAwB,6BAAGC,WAAW,KAAQ,CAC1C,KAAQ,wCADY,YAAxB,+BAEqD,6BAAGA,WAAW,KAAQ,CACvE,KAAQ,+GADyC,uBAFrD,kGAImI,0BAAYA,WAAW,KAAvB,uBAJnI,sIAKA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,qSAcL,6FACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,mMASL,+DACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,+JASL,iBAAQ,CACN,GAAM,8BADR,8BAGA,sEAAqD,6BAAGA,WAAW,KAAQ,CACvE,KAAQ,iDADyC,eAArD,6BAEsD,0BAAYA,WAAW,KAAvB,8BAFtD,6DAGA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,2hBAoBL,mEACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,kPASL,qBAAG,0BAAYA,WAAW,KAAvB,gBAAH,uBAAmF,0BAAYA,WAAW,KAAvB,8BAAnF,KACA,iBAAQ,CACN,GAAM,qBADR,qBAGA,kHAAiG,0BAAYA,WAAW,KAAvB,qBAAjG,qBACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,smBAqBL,qBAAG,0BAAYA,WAAW,KAAvB,kBAAH,iBAA+E,6BAAGA,WAAW,KAAQ,CACjG,KAAQ,2EADmE,QAA/E,+DAGA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,mUAmBL,iBAAQ,CACN,GAAM,4BADR,4BAGA,iGAAgF,0BAAYA,WAAW,KAAvB,qBAAhF,KACA,uBAAK,gCAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,6iCAqCL,qBAAG,0BAAYA,WAAW,KAAvB,iBAAH,QAAqE,0BAAYA,WAAW,KAAvB,iBAArE,kBAAiJ,6BAAGA,WAAW,KAAQ,CACnK,KAAQ,wDADqI,QAAjJ,W,gOAOJJ,EAAWK,gBAAiB","file":"component---docs-guides-structured-and-sequence-selectors-md-3e6c8ca82425b3cc272d.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/travis/build/sgrishchenko/reselect-utils/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"structured--sequence-selectors\"\n    }}>{`Structured & Sequence Selectors`}</h1>\n    <h2 {...{\n      \"id\": \"structured-selector\"\n    }}>{`Structured Selector`}</h2>\n    <p>{`If you ever used `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/reduxjs/reselect\"\n      }}>{`Reselect`}</a>{`, you must be familiar with `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/reduxjs/reselect#createstructuredselectorinputselectors-selectorcreator--createselector\"\n      }}>{`Structured Selector`}</a>{`. Reselect Utils provides implementation of this helper but with improved typings. You can use `}<inlineCode parentName=\"p\">{`Structured Selector`}</inlineCode>{` from this library with heterogeneous selectors. Heterogeneous selectors are selectors with different types of state. See example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`type PersonsStateSlice = {\n  persons: Record<number, Person>;\n};\n\nconst personsSelector = (state: PersonsStateSlice) => state.persons;\n\ntype MessagesStateSlice = {\n  messages: Record<number, Message>;\n};\n\nconst messagesSelector = (state: MessagesStateSlice) => state.messages;\n`}</code></pre>\n    <p>{`Now we can write a selector what select data from both state slices:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { createStructuredSelector } from 'reselect-utils';\n\nconst personsAndMessagesSelector = createStructuredSelector({\n  persons: personsSelector,\n  messages: messagesSelector,\n});\n`}</code></pre>\n    <p>{`You can also use alias to reduce code:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { struct } from 'reselect-utils';\n\nconst personsAndMessagesSelector = struct({\n  persons: personsSelector,\n  messages: messagesSelector,\n});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"cached-structured-selector\"\n    }}>{`Cached Structured Selector`}</h2>\n    <p>{`If you use a parametric selector, you can use `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/toomuchdesign/re-reselect\"\n      }}>{`Re-reselect`}</a>{`. Reselect Utils provides `}<inlineCode parentName=\"p\">{`Cached Structured Selector`}</inlineCode>{` for these purposes. For example, we have next selectors:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { createCachedSelector } from 're-reselect';\n\nconst personSelector = createCachedSelector(\n  personsSelector,\n  (state: PersonsStateSlice, props: Props) => props.personId,\n  (persons, personId) => persons[personId],\n)({\n  keySelector: (state, props) => props.personId,\n});\n\nconst messageSelector = createCachedSelector(\n  messagesSelector,\n  (state: MessagesStateSlice, props: Props) => props.messageId,\n  (messages, messageId) => messages[messageId],\n)({\n  keySelector: (state, props) => props.messageId,\n});\n`}</code></pre>\n    <p>{`You can write composing selector this way:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { cachedStruct } from 'reselect-utils';\n\nconst personAndMessageSelector = cachedStruct({\n  persons: personSelector,\n  messages: messageSelector,\n})({ keySelector: (state, props) => \\`\\${props.personId}:\\${props.messageId}\\` });\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`cachedStruct`}</inlineCode>{` is short alias for `}<inlineCode parentName=\"p\">{`Cached Structured Selector`}</inlineCode>{`.`}</p>\n    <h2 {...{\n      \"id\": \"sequence-selector\"\n    }}>{`Sequence Selector`}</h2>\n    <p>{`There is also another type of structure besides objects - arrays. Reselect Utils provides `}<inlineCode parentName=\"p\">{`Sequence Selector`}</inlineCode>{` helper for them:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { createCachedSelector } from 're-reselect';\nimport { bound, createSequenceSelector } from 'reselect-utils';\n\nconst personSelector = createCachedSelector(\n  personsSelector,\n  (state: PersonsStateSlice, props: Props) => props.personId,\n  (persons, personId) => persons[personId],\n)({\n  keySelector: (state, props) => props.personId,\n});\n\nconst firstPersonSelector = bound(personSelector, { personId: 1 });\nconst secondPersonSelector = bound(personSelector, { personId: 2 });\n\nconst firstTwoPersonsSelector = createSequenceSelector([\n  firstPersonSelector,\n  secondPersonSelector,\n]);\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`Bound Selector`}</inlineCode>{` is described `}<a parentName=\"p\" {...{\n        \"href\": \"/reselect-utils/docz/guides/bound-and-adapted-selectors#bound-selector\"\n      }}>{`here`}</a>{`. Now if you have next state, you will receive next result:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const state = {\n  persons: {\n    1: {\n      id: 1,\n      firstName: 'Marry',\n      secondName: 'Poppins',\n    },\n    2: {\n      id: 2,\n      firstName: 'Harry',\n      secondName: 'Potter',\n    },\n  },\n};\n\nfirstTwoPersonsSelector(state); // => [{ firstName: 'Marry', ... }, { firstName: 'Harry', ... }]\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"cached-sequence-selector\"\n    }}>{`Cached Sequence Selector`}</h2>\n    <p>{`If you try to combine parametric selectors, there is a cached version of `}<inlineCode parentName=\"p\">{`Sequence Selector`}</inlineCode>{`:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { createCachedSelector } from 're-reselect';\nimport { path, prop, bound, cachedSeq } from 'reselect-utils';\n\ntype Props = {\n  personId: number;\n  postfix: string;\n};\n\nconst personFullNameSelector = createCachedSelector(\n  path(personSelector).firstName(),\n  path(personSelector).secondName(),\n  prop<Props>().postfix(),\n  (firstName, secondName, postfix) => \\`\\${firstName} \\${secondName} (\\${postfix})\\`,\n)({\n  keySelector: (state, props) => \\`\\${props.personId}:\\${props.postfix}\\`,\n});\n\nconst firstPersonFullNameSelector = bound(personFullNameSelector, {\n  personId: 1,\n});\nconst secondPersonFullNameSelector = bound(personFullNameSelector, {\n  personId: 2,\n});\n\nconst firstTwoPersonFullNamesSelector = cachedSeq([\n  firstPersonFullNameSelector,\n  secondPersonFullNameSelector,\n])({\n  keySelector: prop<Props>().postfix(),\n});\n\nfirstTwoPersonsSelector(state, { postfix: '*' }); // => ['Marry Poppins (*)', 'Harry Potter (*)' }]\n\nfirstTwoPersonsSelector(state, { postfix: '?' }); // => ['Marry Poppins (?)', 'Harry Potter (?)' }]\n`}</code></pre>\n    <p><inlineCode parentName=\"p\">{`Path Selector`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`Prop Selector`}</inlineCode>{` are described `}<a parentName=\"p\" {...{\n        \"href\": \"/reselect-utils/docz/guides/path-and-prop-selectors\"\n      }}>{`here`}</a>{`.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}